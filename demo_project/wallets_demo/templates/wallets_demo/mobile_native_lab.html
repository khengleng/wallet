{% extends 'wallets_demo/base.html' %}

{% block title %}Mobile Service Playground - {{ org_name }}{% endblock %}

{% block extra_style %}
<style>
  .lab-grid {
    display: grid;
    grid-template-columns: minmax(320px, 420px) minmax(0, 1fr);
    gap: 1rem;
    align-items: start;
  }

  .phone-shell {
    background: #101827;
    border-radius: 2rem;
    padding: 0.8rem;
    box-shadow: 0 14px 32px rgba(2, 8, 23, 0.35);
    max-height: 78vh;
    position: sticky;
    top: 96px;
  }

  .phone-screen {
    background: linear-gradient(160deg, #f9fbff 0%, #eef5ff 100%);
    border-radius: 1.4rem;
    min-height: 70vh;
    max-height: 70vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid #d9e4f5;
  }

  .phone-header {
    padding: 0.9rem 1rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #dbe3ee;
    background: rgba(255, 255, 255, 0.72);
    backdrop-filter: blur(8px);
  }

  .chat-log {
    flex: 1;
    overflow-y: auto;
    padding: 0.85rem;
    display: flex;
    flex-direction: column;
    gap: 0.6rem;
  }

  .chat-msg {
    padding: 0.55rem 0.7rem;
    border-radius: 0.8rem;
    max-width: 82%;
    border: 1px solid #dbe3ee;
    font-size: 0.9rem;
    white-space: pre-wrap;
  }

  .chat-msg.user {
    align-self: flex-end;
    background: #0f4c81;
    color: #fff;
    border-color: #0f4c81;
  }

  .chat-msg.bot {
    align-self: flex-start;
    background: #fff;
  }

  .phone-input {
    border-top: 1px solid #dbe3ee;
    padding: 0.7rem;
    display: grid;
    grid-template-columns: 1fr auto;
    gap: 0.5rem;
    background: #fff;
  }

  .bottom-tabs {
    border-top: 1px solid #dbe3ee;
    background: #fff;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 0.25rem;
    padding: 0.45rem;
  }

  .tab-btn {
    border: none;
    padding: 0.5rem 0.4rem;
    background: transparent;
    border-radius: 0.6rem;
    font-size: 0.76rem;
    font-weight: 600;
    color: #334155;
    cursor: pointer;
  }

  .tab-btn.active {
    background: #e9f2fc;
    color: #0f4c81;
  }

  .panel {
    display: none;
  }

  .panel.active {
    display: block;
  }

  .mono {
    font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
    font-size: 0.78rem;
    white-space: pre-wrap;
    background: #f8fafc;
    border: 1px solid #dbe3ee;
    border-radius: 0.65rem;
    padding: 0.7rem;
    max-height: 310px;
    overflow: auto;
  }
  .tx-sheet {
    border: 1px solid #dbe3ee;
    border-radius: 0.75rem;
    padding: 0.75rem;
    background: #f8fbff;
  }

  @media (max-width: 1080px) {
    .lab-grid { grid-template-columns: 1fr; }
    .phone-shell { position: static; max-height: none; }
    .phone-screen { max-height: none; min-height: 62vh; }
  }
</style>
{% endblock %}

{% block content %}
<div class="card">
  <h2>Mobile Service Playground</h2>
  <p class="text-muted">Business operator playground to test new mobile channel services before native app implementation.</p>
  <div class="form-group">
    <label>Test Account Mode</label>
    <select id="auth-mode">
      <option value="session">Session User (current portal account)</option>
      <option value="token">Bearer Token (different mobile user)</option>
    </select>
  </div>
  <div id="token-mode-panel" style="display:none;">
    <div class="form-group">
      <label>Mobile User Access Token</label>
      <textarea id="override-token" rows="3" placeholder="Paste Keycloak access token for target mobile user"></textarea>
    </div>
    <div class="flex gap-2">
      <button id="btn-save-token" class="btn btn-outline" type="button">Save Token</button>
      <button id="btn-clear-token" class="btn btn-outline" type="button">Clear Token</button>
    </div>
  </div>
  <div id="session-impersonation-panel">
    <div class="form-group">
      <label>Test As Another User (Session Mode)</label>
      <select id="persona-select">
        <option value="">Loading personas...</option>
      </select>
    </div>
    <div class="flex gap-2">
      <button id="btn-apply-persona" class="btn btn-outline" type="button">Apply Persona</button>
      <button id="btn-clear-persona" class="btn btn-outline" type="button">Reset to My Account</button>
    </div>
    <div id="persona-status" class="text-muted" style="margin-top:0.45rem; font-size:0.84rem;">
      Effective user: loading...
    </div>
  </div>
  {% if not has_oidc_token %}
  <div class="alert alert-warning">
    Keycloak access token is not present in this web session. Assistant and gateway calls may fail until you sign in through SSO again.
  </div>
  {% endif %}
</div>

<div class="lab-grid">
  <section class="phone-shell">
    <div class="phone-screen">
      <div class="phone-header">
        <div>
          <strong>Mobile Playground</strong>
          <div class="text-muted" style="font-size:0.75rem;">Business operator sandbox</div>
        </div>
        <span class="badge badge-info">Lab</span>
      </div>

      <div id="screen-home" class="panel active" style="padding:0.9rem; overflow:auto;">
        <h3 style="margin-bottom:0.6rem;">Home Personalization</h3>
        <button id="btn-load-home" class="btn btn-primary" style="width:100%;">Load Personalization</button>
        <div id="home-output" class="mono" style="margin-top:0.7rem;">{}</div>
      </div>

      <div id="screen-profile" class="panel" style="padding:0.9rem; overflow:auto;">
        <h3 style="margin-bottom:0.6rem;">Profile</h3>
        <div class="form-group"><label>First Name</label><input id="pf-first" type="text" /></div>
        <div class="form-group"><label>Last Name</label><input id="pf-last" type="text" /></div>
        <div class="form-group"><label>Legal Name</label><input id="pf-legal" type="text" /></div>
        <div class="form-group"><label>Mobile No</label><input id="pf-mobile" type="text" /></div>
        <div class="form-group"><label>Profile Picture URL</label><input id="pf-avatar" type="url" /></div>
        <div class="form-group"><label>Transaction PIN (4-8 digits)</label><input id="pf-pin" type="password" inputmode="numeric" placeholder="Set/rotate PIN" /></div>
        <div class="form-group"><label>Confirm PIN</label><input id="pf-pin-confirm" type="password" inputmode="numeric" placeholder="Confirm PIN" /></div>
        <div id="pf-pin-status" class="text-muted" style="font-size:0.82rem; margin-bottom:0.45rem;">PIN status: unknown</div>
        <button id="btn-save-profile" class="btn btn-primary" style="width:100%;">Save Profile</button>
      </div>

      <div id="screen-chat" class="panel active-chat" style="display:none;">
        <div id="chat-log" class="chat-log">
          <div class="chat-msg bot">Assistant ready. Ask anything about wallet usage.</div>
        </div>
        <div class="phone-input">
          <input id="chat-input" type="text" placeholder="Ask wallet assistant..." />
          <button id="btn-chat-send" class="btn btn-primary">Send</button>
        </div>
      </div>

      <div id="screen-signals" class="panel" style="padding:0.9rem; overflow:auto;">
        <h3 style="margin-bottom:0.6rem;">Behavior Signals</h3>
        <div class="form-group">
          <label>Data Points (JSON)</label>
          <textarea id="signals-json" rows="6">{"last_screen":"home","preferred_entry_point":"scan_pay","avg_session_seconds":420}</textarea>
        </div>
        <button id="btn-save-signals" class="btn btn-primary" style="width:100%;">Save Signals</button>
      </div>

      <div id="screen-playground" class="panel" style="padding:0.9rem; overflow:auto;">
        <h3 style="margin-bottom:0.6rem;">Service Sandbox</h3>
        <div class="form-group">
          <label>Preset Service Test</label>
          <select id="preset-select">
            <option value="">Select preset</option>
            {% for endpoint in playground_endpoints %}
            <option value="{{ endpoint.path }}" data-method="{{ endpoint.method }}">{{ endpoint.name }} - {{ endpoint.path }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="form-group">
          <label>Method</label>
          <select id="sandbox-method">
            <option value="GET">GET</option>
            <option value="POST">POST</option>
          </select>
        </div>
        <div class="form-group">
          <label>Path</label>
          <input id="sandbox-path" type="text" value="/api/mobile/bootstrap/" />
        </div>
        <div class="form-group">
          <label>Payload JSON</label>
          <textarea id="sandbox-body" rows="6">{}</textarea>
        </div>
        <button id="btn-run-sandbox" class="btn btn-primary" style="width:100%;">Run Service Test</button>
      </div>

      <div class="bottom-tabs">
        <button class="tab-btn active" data-screen="home">Home</button>
        <button class="tab-btn" data-screen="profile">Profile</button>
        <button class="tab-btn" data-screen="chat">Assistant</button>
        <button class="tab-btn" data-screen="signals">Signals</button>
        <button class="tab-btn" data-screen="playground">Sandbox</button>
      </div>
    </div>
  </section>

  <section>
    <div class="card">
      <h3>API Output</h3>
      <p class="text-muted">Live responses from mobile APIs.</p>
      <div id="api-output" class="mono">Waiting for action...</div>
    </div>
    <div class="card">
      <h3>Assistant Prompt Playground</h3>
      <p class="text-muted">Use this to chat directly even if the phone tab is not active.</p>
      <div class="form-group">
        <label>Prompt</label>
        <textarea id="assistant-prompt" rows="4" placeholder="Ask the assistant, e.g. How can I transfer 100 USD safely?"></textarea>
      </div>
      <div class="flex gap-2">
        <button id="btn-assistant-send" class="btn btn-primary" type="button">Send Prompt</button>
        <button id="btn-assistant-clear" class="btn btn-outline" type="button">Clear Chat</button>
      </div>
    </div>
    <div class="card">
      <h3>Transaction Commit Sheet</h3>
      <p class="text-muted">Assistant transaction requests open this secure form. Review, preview, then commit with PIN.</p>
      <div id="tx-sheet-status" class="text-muted" style="margin-bottom:0.6rem;">Waiting for assistant transaction request.</div>
      <div class="tx-sheet">
        <div class="form-group">
          <label>Action</label>
          <select id="tx-action">
            <option value="transfer">transfer</option>
            <option value="deposit">deposit</option>
            <option value="withdraw">withdraw</option>
          </select>
        </div>
        <div class="form-group"><label>Amount</label><input id="tx-amount" type="text" value="0" /></div>
        <div class="form-group"><label>Currency</label><input id="tx-currency" type="text" value="USD" /></div>
        <div class="form-group"><label>From Username</label><input id="tx-from-username" type="text" /></div>
        <div class="form-group"><label>To Username (transfer only)</label><input id="tx-to-username" type="text" /></div>
        <div class="form-group"><label>Description</label><input id="tx-description" type="text" value="assistant_transfer" /></div>
        <div class="form-group"><label>Transaction PIN</label><input id="tx-pin" type="password" inputmode="numeric" placeholder="PIN required for commit" /></div>
        <div class="flex gap-2">
          <button id="btn-tx-preview" class="btn btn-outline" type="button">Preview</button>
          <button id="btn-tx-commit" class="btn btn-primary" type="button">Commit Transaction</button>
          <button id="btn-tx-reset" class="btn btn-outline" type="button">Reset</button>
        </div>
      </div>
    </div>
    <div class="card">
      <h3>Assistant Diagnostics</h3>
      <p class="text-muted">Check token/session state, channel connectivity, and AI readiness.</p>
      <button id="btn-run-diagnostics" class="btn btn-primary" type="button">Run Diagnostics</button>
      <div id="diagnostics-output" class="mono" style="margin-top:0.7rem;">Waiting for diagnostic run...</div>
    </div>
  </section>
</div>

<script>
  (function() {
    const csrfToken = "{{ csrf_token }}";
    const accessToken = "{{ oidc_access_token|escapejs }}";
    const gatewayBase = "{{ mobile_gateway_base|escapejs }}";

    const apiOutput = document.getElementById("api-output");
    const homeOutput = document.getElementById("home-output");
    const diagnosticsOutput = document.getElementById("diagnostics-output");

    const authModeEl = document.getElementById("auth-mode");
    const tokenPanelEl = document.getElementById("token-mode-panel");
    const overrideTokenEl = document.getElementById("override-token");
    const personaPanelEl = document.getElementById("session-impersonation-panel");
    const personaSelectEl = document.getElementById("persona-select");
    const personaStatusEl = document.getElementById("persona-status");
    const pinStatusEl = document.getElementById("pf-pin-status");
    const txSheetStatusEl = document.getElementById("tx-sheet-status");

    function getOverrideToken() {
      return (overrideTokenEl.value || "").trim();
    }

    function getActiveToken() {
      if (authModeEl.value === "token") {
        return getOverrideToken();
      }
      return (accessToken || "").trim();
    }

    function authHeaders() {
      const token = getActiveToken();
      if (!token) return null;
      return {
        "Content-Type": "application/json",
        "Authorization": "Bearer " + token
      };
    }

    function assistantHeaders() {
      const headers = {
        "Content-Type": "application/json",
        "X-CSRFToken": csrfToken
      };
      const token = getActiveToken();
      if (token) {
        headers["Authorization"] = "Bearer " + token;
      }
      return headers;
    }

    function inTokenMode() {
      return authModeEl.value === "token";
    }

    function setOutput(obj) {
      apiOutput.textContent = JSON.stringify(obj, null, 2);
    }

    function setDiagnostics(obj) {
      diagnosticsOutput.textContent = JSON.stringify(obj, null, 2);
    }

    function setPersonaStatus(text) {
      personaStatusEl.textContent = text;
    }
    function setTxSheetStatus(text) {
      txSheetStatusEl.textContent = text;
    }

    function updateModePanels() {
      const tokenMode = authModeEl.value === "token";
      tokenPanelEl.style.display = tokenMode ? "block" : "none";
      personaPanelEl.style.display = tokenMode ? "none" : "block";
    }

    function parseMaybeJson(raw) {
      if (!raw) return {};
      try {
        return JSON.parse(raw);
      } catch (_) {
        return { raw: raw };
      }
    }

    function normalizeError(err) {
      if (!err) return { message: "Unknown error" };
      if (err.status) return err;
      if (err.message) return { message: err.message };
      return { message: String(err) };
    }

    async function callJson(url, options) {
      let res;
      try {
        res = await fetch(url, options);
      } catch (err) {
        throw { status: 0, message: "Network error", details: String(err), url: url };
      }

      const raw = await res.text();
      const body = parseMaybeJson(raw);
      if (!res.ok) {
        throw {
          status: res.status,
          status_text: res.statusText,
          url: url,
          body: body
        };
      }
      return body;
    }

    async function loadHome() {
      try {
        let personalization;
        if (inTokenMode()) {
          const headers = authHeaders();
          if (!headers) {
            setOutput({ error: "Token mode selected but no token provided." });
            return;
          }
          personalization = await callJson(gatewayBase + "/personalization", { method: "GET", headers: headers });
        } else {
          personalization = await callJson("/api/mobile/personalization/", { method: "GET" });
        }
        homeOutput.textContent = JSON.stringify(personalization, null, 2);
        setOutput(personalization);
      } catch (err) {
        setOutput({ error: normalizeError(err) });
      }
    }

    async function loadProfile() {
      try {
        let p;
        if (inTokenMode()) {
          const headers = authHeaders();
          if (!headers) {
            setOutput({ error: "Token mode selected but no token provided." });
            return;
          }
          p = await callJson(gatewayBase + "/profile", { method: "GET", headers: headers });
        } else {
          p = await callJson("/api/mobile/profile/", { method: "GET" });
        }
        const user = (p.data || {}).user || {};
        const cif = (p.data || {}).cif || {};
        document.getElementById("pf-first").value = user.first_name || "";
        document.getElementById("pf-last").value = user.last_name || "";
        document.getElementById("pf-legal").value = cif.legal_name || "";
        document.getElementById("pf-mobile").value = cif.mobile_no || "";
        document.getElementById("pf-avatar").value = user.profile_picture_url || "";
        document.getElementById("pf-pin").value = "";
        document.getElementById("pf-pin-confirm").value = "";
        pinStatusEl.textContent = "PIN status: " + (user.transaction_pin_configured ? "configured" : "not configured");
        document.getElementById("tx-from-username").value = user.username || "";
        setOutput(p);
      } catch (err) {
        setOutput({ error: normalizeError(err) });
      }
    }

    async function saveProfile() {
      const payload = {
        first_name: document.getElementById("pf-first").value.trim(),
        last_name: document.getElementById("pf-last").value.trim(),
        legal_name: document.getElementById("pf-legal").value.trim(),
        mobile_no: document.getElementById("pf-mobile").value.trim(),
        profile_picture_url: document.getElementById("pf-avatar").value.trim(),
        transaction_pin: document.getElementById("pf-pin").value.trim(),
        transaction_pin_confirm: document.getElementById("pf-pin-confirm").value.trim(),
      };
      try {
        let p;
        if (inTokenMode()) {
          const headers = authHeaders();
          if (!headers) {
            setOutput({ error: "Token mode selected but no token provided." });
            return;
          }
          p = await callJson(gatewayBase + "/profile", {
            method: "POST",
            headers: headers,
            body: JSON.stringify(payload)
          });
        } else {
          p = await callJson("/api/mobile/profile/", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": csrfToken
            },
            body: JSON.stringify(payload)
          });
        }
        setOutput(p);
        pinStatusEl.textContent = "PIN status: " + (((p.data || {}).user || {}).transaction_pin_configured ? "configured" : "not configured");
        document.getElementById("pf-pin").value = "";
        document.getElementById("pf-pin-confirm").value = "";
      } catch (err) {
        setOutput({ error: normalizeError(err) });
      }
    }

    function txPayload(execute) {
      return {
        action: (document.getElementById("tx-action").value || "").trim().toLowerCase(),
        amount: (document.getElementById("tx-amount").value || "").trim(),
        currency: (document.getElementById("tx-currency").value || "").trim().toUpperCase(),
        from_username: (document.getElementById("tx-from-username").value || "").trim(),
        to_username: (document.getElementById("tx-to-username").value || "").trim(),
        description: (document.getElementById("tx-description").value || "").trim() || "assistant_txn",
        execute: !!execute,
        pin: (document.getElementById("tx-pin").value || "").trim(),
      };
    }

    async function runTxAction(execute) {
      const payload = txPayload(execute);
      if (execute && !payload.pin) {
        setOutput({ error: "PIN is required for commit." });
        setTxSheetStatus("Commit blocked: PIN required.");
        return;
      }
      try {
        const body = await callJson("/api/playground/assistant/action/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken
          },
          body: JSON.stringify(payload)
        });
        setOutput(body);
        const data = (body || {}).data || {};
        if (data.allowed && data.execute) {
          setTxSheetStatus("Transaction committed successfully.");
          document.getElementById("tx-pin").value = "";
        } else if (data.allowed) {
          setTxSheetStatus("Preview passed. Fee: " + (data.tariff_fee || "0"));
        } else {
          setTxSheetStatus("Blocked: " + (data.reason || "policy or balance check failed"));
        }
      } catch (err) {
        setTxSheetStatus("Transaction call failed.");
        setOutput({ error: normalizeError(err) });
      }
    }

    function openTxSheetFromProposal(proposal) {
      if (!proposal || proposal.kind !== "transaction_request") return;
      const prefill = proposal.prefill || {};
      document.getElementById("tx-action").value = (prefill.action || "transfer").toLowerCase();
      document.getElementById("tx-amount").value = prefill.amount || "0";
      document.getElementById("tx-currency").value = (prefill.currency || "USD").toUpperCase();
      document.getElementById("tx-from-username").value = prefill.from_username || "";
      document.getElementById("tx-to-username").value = prefill.to_username || "";
      document.getElementById("tx-description").value = prefill.description || "assistant_txn";
      setTxSheetStatus("Assistant prepared transaction. Review and commit with PIN.");
    }

    async function saveSignals() {
      let dataPoints = {};
      try {
        dataPoints = JSON.parse(document.getElementById("signals-json").value);
      } catch (_) {
        setOutput({ error: "Invalid JSON in signals" });
        return;
      }
      try {
        let p;
        if (inTokenMode()) {
          const headers = authHeaders();
          if (!headers) {
            setOutput({ error: "Token mode selected but no token provided." });
            return;
          }
          p = await callJson(gatewayBase + "/personalization/signals", {
            method: "POST",
            headers: headers,
            body: JSON.stringify({ data_points: dataPoints })
          });
        } else {
          p = await callJson("/api/mobile/personalization/signals/", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CSRFToken": csrfToken
            },
            body: JSON.stringify({ data_points: dataPoints })
          });
        }
        setOutput(p);
      } catch (err) {
        setOutput({ error: normalizeError(err) });
      }
    }

    async function runSandbox() {
      const method = document.getElementById("sandbox-method").value;
      const path = document.getElementById("sandbox-path").value.trim();
      if (!path.startsWith("/")) {
        setOutput({ error: "Path must start with /" });
        return;
      }
      let bodyObj = {};
      const rawBody = document.getElementById("sandbox-body").value.trim();
      if (method !== "GET" && rawBody) {
        try {
          bodyObj = JSON.parse(rawBody);
        } catch (_) {
          setOutput({ error: "Invalid JSON body" });
          return;
        }
      }

      const headers = { "Content-Type": "application/json" };
      if (path.startsWith("/mobile/")) {
        const token = getActiveToken();
        if (!token) {
          setOutput({ error: "Access token missing for gateway endpoint" });
          return;
        }
        headers["Authorization"] = "Bearer " + token;
      } else {
        headers["X-CSRFToken"] = csrfToken;
      }

      try {
        const response = await callJson(path, {
          method: method,
          headers: headers,
          body: method === "GET" ? undefined : JSON.stringify(bodyObj),
        });
        setOutput(response);
      } catch (err) {
        setOutput({ error: normalizeError(err) });
      }
    }

    function appendChat(role, text) {
      const log = document.getElementById("chat-log");
      const el = document.createElement("div");
      el.className = "chat-msg " + (role === "user" ? "user" : "bot");
      el.textContent = text;
      log.appendChild(el);
      log.scrollTop = log.scrollHeight;
    }

    async function sendChat() {
      const input = document.getElementById("chat-input");
      const promptBox = document.getElementById("assistant-prompt");
      const message = (input.value || promptBox.value || "").trim();
      if (!message) return;
      input.value = "";
      promptBox.value = "";
      appendChat("user", message);

      try {
        if (inTokenMode() && !getActiveToken()) {
          appendChat("bot", "Token mode selected but no token provided.");
          return;
        }
        const body = await callJson("/api/mobile/assistant/chat/", {
          method: "POST",
          headers: assistantHeaders(),
          body: JSON.stringify({
            message: message,
            context: {
              channel: inTokenMode() ? "native_lab_web_token_mode" : "native_lab_web"
            }
          })
        });
        const reply = ((((body || {}).data || {}).assistant || {}).reply) || "No reply";
        const proposal = ((((body || {}).data || {}).assistant || {}).action_proposal) || null;
        appendChat("bot", reply);
        if (proposal) {
          openTxSheetFromProposal(proposal);
          appendChat("bot", "I prepared a transaction sheet. Please review and commit with PIN.");
        }
        setOutput(body);
      } catch (err) {
        appendChat("bot", "Assistant call failed.");
        setOutput({ error: normalizeError(err) });
      }
    }

    async function probe(url, options) {
      try {
        const body = await callJson(url, options);
        return { ok: true, status: 200, body: body };
      } catch (err) {
        const normalized = normalizeError(err);
        return {
          ok: false,
          status: normalized.status || 0,
          error: normalized
        };
      }
    }

    async function runDiagnostics() {
      if (inTokenMode()) {
        const headers = authHeaders();
        if (!headers) {
          const missing = {
            ok: false,
            mode: "token",
            error: "Token mode selected but no token provided."
          };
          setDiagnostics(missing);
          setOutput(missing);
          return;
        }
        const profileProbe = await probe(gatewayBase + "/profile", { method: "GET", headers: headers });
        const aiProbe = await probe(gatewayBase + "/personalization/ai", { method: "GET", headers: headers });
        const aiBody = ((aiProbe.body || {}).data || {}).ai || {};
        const diag = {
          ok: true,
          mode: "token",
          token_present: true,
          gateway_profile: profileProbe,
          gateway_ai: aiProbe,
          assistant_status: {
            enabled: !!aiBody.enabled,
            reason: aiBody.reason || "",
            source: "gateway/mobile-bff"
          },
          timestamp: new Date().toISOString()
        };
        setDiagnostics(diag);
        setOutput(diag);
        return;
      }

      const diag = await probe("/api/mobile/assistant/diagnostics/", { method: "GET" });
      setDiagnostics(diag);
      setOutput(diag);
    }

    async function loadPersonas() {
      try {
        const body = await callJson("/api/playground/personas/", { method: "GET" });
        const personas = (((body || {}).data || {}).personas) || [];
        personaSelectEl.innerHTML = "";
        if (!personas.length) {
          const noneOption = document.createElement("option");
          noneOption.value = "";
          noneOption.textContent = "No personas available";
          personaSelectEl.appendChild(noneOption);
          setPersonaStatus("Effective user: current portal account");
          return;
        }
        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = "Select user profile";
        personaSelectEl.appendChild(defaultOption);
        personas.forEach((persona) => {
          if (!persona.username) return;
          const option = document.createElement("option");
          option.value = persona.username;
          const serviceClass = persona.service_class ? " | class " + persona.service_class : "";
          option.textContent = persona.username + " (" + (persona.wallet_type || "C") + serviceClass + ")";
          personaSelectEl.appendChild(option);
        });
      } catch (err) {
        personaSelectEl.innerHTML = '<option value="">Failed to load personas</option>';
        setOutput({ error: normalizeError(err) });
      }
    }

    async function loadImpersonationStatus() {
      try {
        const body = await callJson("/api/playground/impersonation/", { method: "GET" });
        const effective = (((body || {}).data || {}).effective_user) || null;
        if (effective && effective.username) {
          personaSelectEl.value = effective.username;
          setPersonaStatus("Effective user: " + effective.username + " (" + (effective.email || "no-email") + ")");
        } else {
          setPersonaStatus("Effective user: current portal account");
          personaSelectEl.value = "";
        }
      } catch (err) {
        setPersonaStatus("Effective user: unavailable");
        setOutput({ error: normalizeError(err) });
      }
    }

    async function applyPersona() {
      const username = (personaSelectEl.value || "").trim();
      if (!username) {
        setOutput({ error: "Select a user profile first." });
        return;
      }
      try {
        const body = await callJson("/api/playground/impersonation/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrfToken
          },
          body: JSON.stringify({ username: username })
        });
        setOutput(body);
        await loadImpersonationStatus();
        await loadHome();
      } catch (err) {
        setOutput({ error: normalizeError(err) });
      }
    }

    async function clearPersona() {
      try {
        const body = await callJson("/api/playground/impersonation/", {
          method: "DELETE",
          headers: {
            "X-CSRFToken": csrfToken
          }
        });
        setOutput(body);
        await loadImpersonationStatus();
        await loadHome();
      } catch (err) {
        setOutput({ error: normalizeError(err) });
      }
    }

    document.getElementById("btn-load-home").addEventListener("click", loadHome);
    document.getElementById("btn-save-profile").addEventListener("click", saveProfile);
    document.getElementById("btn-save-signals").addEventListener("click", saveSignals);
    document.getElementById("btn-run-sandbox").addEventListener("click", runSandbox);
    document.getElementById("btn-chat-send").addEventListener("click", sendChat);
    document.getElementById("btn-assistant-send").addEventListener("click", sendChat);
    document.getElementById("btn-run-diagnostics").addEventListener("click", runDiagnostics);
    document.getElementById("btn-tx-preview").addEventListener("click", function() { runTxAction(false); });
    document.getElementById("btn-tx-commit").addEventListener("click", function() { runTxAction(true); });
    document.getElementById("btn-tx-reset").addEventListener("click", function() {
      document.getElementById("tx-action").value = "transfer";
      document.getElementById("tx-amount").value = "0";
      document.getElementById("tx-currency").value = "USD";
      document.getElementById("tx-from-username").value = "";
      document.getElementById("tx-to-username").value = "";
      document.getElementById("tx-description").value = "assistant_transfer";
      document.getElementById("tx-pin").value = "";
      setTxSheetStatus("Transaction sheet reset.");
    });
    document.getElementById("btn-assistant-clear").addEventListener("click", function() {
      const log = document.getElementById("chat-log");
      log.innerHTML = '<div class="chat-msg bot">Assistant ready. Ask anything about wallet usage.</div>';
      setOutput({ chat_cleared: true });
    });
    document.getElementById("chat-input").addEventListener("keydown", function(e) {
      if (e.key === "Enter") sendChat();
    });

    document.querySelectorAll(".tab-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".tab-btn").forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        const target = btn.getAttribute("data-screen");
        document.querySelectorAll(".panel").forEach((panel) => panel.classList.remove("active"));
        document.getElementById("screen-" + target).classList.add("active");
        if (target === "profile") loadProfile();
        if (target === "home") loadHome();
      });
    });

    document.getElementById("preset-select").addEventListener("change", function() {
      const option = this.options[this.selectedIndex];
      if (!option || !option.value) return;
      document.getElementById("sandbox-path").value = option.value;
      document.getElementById("sandbox-method").value = option.getAttribute("data-method") || "GET";
      if (option.value === "/mobile/v1/assistant/chat") {
        document.getElementById("sandbox-body").value =
          JSON.stringify({ message: "Summarize my wallet insights.", context: { channel: "playground" } }, null, 2);
      } else {
        document.getElementById("sandbox-body").value = "{}";
      }
    });

    authModeEl.addEventListener("change", function() {
      updateModePanels();
      setOutput({ mode: this.value });
    });
    document.getElementById("btn-save-token").addEventListener("click", function() {
      const token = getOverrideToken();
      localStorage.setItem("mobile_playground_override_token", token);
      setOutput({ token_saved: !!token, length: token.length });
    });
    document.getElementById("btn-clear-token").addEventListener("click", function() {
      overrideTokenEl.value = "";
      localStorage.removeItem("mobile_playground_override_token");
      setOutput({ token_cleared: true });
    });
    document.getElementById("btn-apply-persona").addEventListener("click", applyPersona);
    document.getElementById("btn-clear-persona").addEventListener("click", clearPersona);

    const cachedToken = localStorage.getItem("mobile_playground_override_token");
    if (cachedToken) {
      overrideTokenEl.value = cachedToken;
    }

    updateModePanels();
    loadPersonas().then(loadImpersonationStatus);
    loadHome();
    runDiagnostics();
  })();
</script>
{% endblock %}
